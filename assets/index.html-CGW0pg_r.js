import{_ as r,c as t,d as e,o as a}from"./app-DoO5dwbX.js";const s="/assets/image-9AJAOG68.png",o={};function p(i,n){return a(),t("div",null,n[0]||(n[0]=[e('<p><strong>机器数</strong>：各种数值在计算机中表示的形式，其特点是使用二进制计数制，数的符号用 0 和 1 表示，小数点则隐含，不占位置。</p><p>机器数有无符号数和带符号数之分。</p><ul><li>无符号数表示正数，没有符号位。</li><li>带符号数最高位为符号位，正数符号位为 0，负数符号位为 1。</li></ul><p><strong>真值</strong>：机器数对应的实际数值。</p><h2 id="原码、反码、补码" tabindex="-1"><a class="header-anchor" href="#原码、反码、补码"><span>原码、反码、补码</span></a></h2><p><strong>正数</strong>：原码=反码=补码</p><p><strong>负数</strong>：原码是绝对值的原码，然后把最高位（符号位）改为 1；反码=（除符号位外）原码按位取反；补码=（除符号位外）反码+1。</p><p><strong>0</strong>：分为 +0 和 -0</p><ul><li>+0：原码：0000 0000；反码：0000 0000；补码：0000 0000</li><li>-0：原码：1000 0000；反码：1111 1111；补码：0000 0000（溢出后舍弃最高位）</li></ul><h2 id="移码" tabindex="-1"><a class="header-anchor" href="#移码"><span>移码</span></a></h2><p>补码首位（即符号位）取反。</p><p>移码用作浮点运算的阶码。</p><h2 id="机器字长为-n-时-各种码制的表示范围-定点整数" tabindex="-1"><a class="header-anchor" href="#机器字长为-n-时-各种码制的表示范围-定点整数"><span>机器字长为 n 时，各种码制的表示范围（定点整数）</span></a></h2><p><strong>原码</strong>：n 位数最高位是符号位，剩下（n-1）位表示数值大小，此时可表示 2n-1-1 个数，所以最小负数是 -（2n-1-1）。同理，最大正数为 2n-1-1。即原码的表示范围是 -(2n-1-1)~ +(2n-1-1) 。</p><p><strong>反码</strong>：和原码一样，反码的表示范围也是 -(2n-1-1)~ +(2n-1-1) 。</p><p><strong>补码</strong>：+0、-0 的反码都是 0000 0000，所以补码的表示范围是 -(2n-1)~ +(2n-1-1)</p><p>补码参考：</p><ul><li><a href="https://blog.csdn.net/boomandrice/article/details/126794706" target="_blank" rel="noopener noreferrer">关于进制补码的八位取值范围为什么是-128~127 和补码-128 的求取_补码为什么是-128 到 127-CSDN 博客</a></li><li><a href="https://blog.csdn.net/Brave_Runer/article/details/106512781" target="_blank" rel="noopener noreferrer">为什么用二进制补码所能表示的数据范围比原码多一个数据单位（为什么 8 位二进制的补码取值范围是-128~127）_补码取值范围为什么大一位-CSDN 博客</a>。</li></ul><p><strong>移码</strong>：+0、-0 的反码一样， 所以移码也一样。所以移码的表示范围和补码一样，都是 -(2n-1)~ +(2n-1-1) 。</p><h2 id="机器字长为-n-时-各种码制的表示范围-定点小数" tabindex="-1"><a class="header-anchor" href="#机器字长为-n-时-各种码制的表示范围-定点小数"><span>机器字长为 n 时，各种码制的表示范围（定点小数）</span></a></h2><p>参考链接：（<a href="https://www.zhihu.com/question/50758554" target="_blank" rel="noopener noreferrer">定点小数的取值范围是怎么推算出来的？ - 知乎 (zhihu.com)</a>）</p><p>比如 0011 0011 是一个 8 位原码，此时它是一个整数，小数点位于最右侧（可以看做 0011 0011.0），把它化为小数是 0.011 0011（最高位是符号位），数据向右移动了 n-1 位（相当于小数点向左移动了 n-1 位）。数据右移=小数点左移=除以 2n-1，</p><p><strong>所以定点小数的表示范围就是【整数的表示范围除以 2n-1】</strong></p><p>整数原码范围：-(2n-1-1)~ +(2n-1-1) ，<strong>定点小数原码</strong>范围：-(1-1/2n-1) , 1/2n-1 可以表示为 2-(n-1)，所以范围是 -(1-2-(n-1))~+(1-2-(n-1))</p><p>同理，整数反码范围： -(2n-1-1)~ +(2n-1-1)，<strong>定点小数反码</strong>范围 -(1-2-(n-1))~+(1-2-(n-1))</p><p>同理，整数补码范围： -(2n-1)~ +(2n-1-1) ，<strong>定点小数补码</strong>范围 -1~+(1-2-(n-1))</p><p>同理，移码补码范围： -(2n-1)~ +(2n-1-1) ，<strong>定点小数移码</strong>范围 -1~+(1-2-(n-1))</p><p><img src="'+s+'" alt="alt text"></p><h2 id="浮点数运算" tabindex="-1"><a class="header-anchor" href="#浮点数运算"><span>浮点数运算</span></a></h2><p><strong>数据右移=小数点左移=除以 2n-1</strong></p><p>浮点数的表示方法是 <strong>尾数*2 阶码</strong>，尾数是纯小数，阶码是纯整数。正数表示为 0.1xxxx，负数表示为 1.0xxxx</p><ul><li><p><strong>对阶</strong>：使两个数的阶码相同，<strong>小阶向大阶看齐</strong>，较小阶码增加几位，尾数就右移几位。</p></li><li><p><strong>尾数计算</strong>：相加，如果是减法则加负数；</p></li><li><p><strong>结果规格化</strong>：即尾数规格化，带符号数尾数转换为 1.0xxx 或 0.1xxx。</p></li></ul><p>小阶向大阶看齐 例子：</p><ul><li>0101，数据左移两位 = 乘以 2^2=0100，丢失高位，不能忍受</li><li>数据右移两位 = 除以 2^2=0001，丢失低位，只影响精度，可以忍受</li></ul>',34)]))}const g=r(o,[["render",p]]),c=JSON.parse('{"path":"/computer_science/kdpb8maj/","title":"原码_反码_补码_移码和浮点数对阶","lang":"zh-CN","frontmatter":{"title":"原码_反码_补码_移码和浮点数对阶","createTime":"2025/06/20 16:10:51","permalink":"/computer_science/kdpb8maj/"},"readingTime":{"minutes":3.37,"words":1011},"git":{"createdTime":1750408070000,"updatedTime":1752654641000,"contributors":[{"name":"twoflowers","username":"","email":"1292548615@qq.com","commits":5,"avatar":"https://gravatar.com/avatar/51a398cd538d08b052e061e4b9f2c3353a7fae1d5406ef128cad6096d91bd325?d=retro"}]},"filePathRelative":"notes/computer_science/原码_反码_补码_移码和浮点数对阶.md","headers":[]}');export{g as comp,c as data};
