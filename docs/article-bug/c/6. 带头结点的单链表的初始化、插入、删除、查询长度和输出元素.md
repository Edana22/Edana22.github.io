# 带头结点的单链表的初始化、插入、删除、查询长度和输出元素

带头结点的单链表的初始化、插入、删除、查询长度和输出元素，源码如下：

```
  1 #include<stdio.h> 
  2 #include<math.h>
  3 #include<stdlib.h> 
  4 #include<malloc.h> 
  5 
  6 #define MAXSIZE 10 //定义顺序表最大长度
  7 #define TRUE 1
  8 #define FALSE 0
  9 #define OK 1
 10 #define ERROR 0
 11 #define INFEASIBLE -1
 12 #define LIST_INIT_SIZE 100
 13 #define LISTINCREMENT 10
 14 
 15 typedef int Element;
 16 
 17 typedef struct node{
 18     Element e;
 19     struct node* next;//这里只是声明了一个名为next的指针，指针本身也占内存空间，里面存放的始终是地址。 struct node* 表示指针的类型是 struct node，即指向的地址里存放的是一个结构体 
 20 }LNode, *Linklist;
 21 
 22 /**
 23 * 带头结点的单链表进行增删改查 
 24 * 头结点就可以指代整个链表了 
 25 */
 26 
 27 int main() {
 28     Linklist initLinklist(Linklist head);
 29     int getLength(Linklist head);
 30     Linklist insert(Linklist head, int k, Element e);
 31     Linklist del(Linklist head, int position);
 32     int find(Linklist head, int position);
 33     void output(Linklist head);    
 34     
 35     Linklist head;//头结点 
 36     
 37     head = initLinklist(head); 
 38     insert(head, 1,1);//只有头结点时，长度是0 ，插入位置从1开始算 
 39     insert(head, 2,2);
 40     insert(head, 3,3);
 41     insert (head,2,999);
 42     int listLength = getLength(head);
 43     printf("length is : %d \n",listLength); 
 44     output(head);
 45     
 46     find(head,2);
 47     
 48     del(head, 2); 
 49     listLength = getLength(head);
 50     printf("length is : %d \n",listLength);
 51     output(head);
 52     
 53     del(head, 1);
 54     printf("length is : %d \n",listLength); 
 55     listLength = getLength(head);
 56     output(head);
 57     
 58 }
 59 
 60 /**
 61 * 初始化单链表，建立一个头结点 
 62 */
 63 Linklist initLinklist(Linklist head){
 64     head = (Linklist)malloc(sizeof(LNode));
 65     head->next = NULL;
 66     printf("init single list successful! \n"); 
 67     return head;
 68 }
 69 
 70 /**
 71 * 插入元素 
 72 */
 73 Linklist insert(Linklist head, int k, Element e){
 74     int getLength(Linklist head);
 75     
 76     Linklist p = (Linklist)malloc(sizeof(LNode));//申请一个新节点
 77     Linklist pre = (Linklist)malloc(sizeof(LNode));//申请一个新节点
 78     int length = getLength(head);
 79     pre = head;
 80 
 81     if(k == length+1){    //在链表末尾添加新节点 
 82         while(pre->next) {
 83             pre = pre->next;
 84         }//循环结束时，pre已经到达链表末尾 
 85         p->e = e;
 86         pre->next = p;
 87         p->next = NULL;
 88     }else if(k > 0 && k <= length){//在链表中间添加节点 ，插入位置从1开始算 
 89         int j = 1;
 90         while(j < k) {
 91             pre = pre->next;
 92             j++;
 93         }//循环结束时，pre是要插入位置的前驱节点
 94         p->e = e;
 95         p->next = pre->next;
 96         pre->next = p; 
 97     }else{
 98         printf("插入的位置有误！\n");
 99     }
100     return head;
101 }
102 
103 /**
104 * 删除指定位置的链表元素  
105 */
106 Linklist del(Linklist head, int position) {
107     int getLength(Linklist head) ;
108     
109     int length = getLength(head);
110     if(position <= 0 || position > length ){
111         printf("删除位置有误！\n");
112     }else{
113         Linklist pre = (Linklist)malloc(sizeof(LNode));
114         Linklist key = (Linklist)malloc(sizeof(LNode));//key是被删除的元素 
115         pre = head;
116         int k = 1;
117         while(k < position){
118             pre = pre->next;
119             k++;
120         }//循环结束时，pre是被删除节点的前驱元素
121         key = pre->next;
122         key->e = pre->next->e; 
123         if(position == length) {//被删除的是链表末尾元素 
124             pre->next = NULL;
125         }else{//被删除的是链表中间元素 
126             pre->next = key->next;
127         } 
128         printf("删除的位置是%d, 删除位置的元素是%d \n", position, key->e) ;
129         free(key);
130     }
131     return head;
132 }
133 
134 /**
135 * 查询指定位置的链表元素  
136 */
137 int find(Linklist head, int position){
138     int getLength(Linklist head);
139     
140     Linklist pre = (Linklist)malloc(sizeof(LNode));
141     pre = head;
142     int length = getLength(head);
143     int k = 1;
144     if(position <= length){
145         while(k < position)    {
146             pre = pre->next;
147             k++;
148         }//循环结束时，pre是被查询节点的前驱元素
149         printf("------------------------------\n");
150         printf("位置%d的元素内容是%d\n", position,pre->next->e);
151         printf("------------------------------\n");
152     }else{
153         printf("查询位置有误！\n");
154     }
155 }
156 
157 /**
158 * 输出链表元素  
159 */
160 void output(Linklist head){
161     Linklist p = (Linklist)malloc(sizeof(LNode));//申请一个新节点
162     p = head;
163     do{    
164         p = p->next;
165         printf("%5d", p->e);
166     }while(p->next);
167     printf("\n");
168 }
169 
170 /**
171 * 求单链表的长度 
172 * 长度不算头结点 
173 */
174 int getLength(Linklist head){
175     int length = 0;
176     Linklist p = (Linklist)malloc(sizeof(LNode));//申请一个新节点
177     p = head;
178     while(p->next){
179         length++;
180         p = p->next;
181     }
182     return length;
183 }
运行结果如下：
```

![img](https://img2020.cnblogs.com/blog/2194212/202103/2194212-20210302104929825-1757224601.png)

 